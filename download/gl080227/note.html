<HTML><HEAD><TITLE>GPSロガー 設計メモ</TITLE></HEAD><BODY>

<H1>GPSロガー 設計メモ</H1>

<H2>開発の動機</H2>

<P> このシステムは、2004年8月に実施されたSWEST6会場で、Surveyorチームが複雑な設計のGPSロガーの調整に苦労していたのを見て、もっと単純で誰にでも作れるGPSロガーを設計しようと考えたことがきっかけとなって生まれました。</P>

<P> そのとき苦労していたのは、フラットパッケージの半田付けと、DC-DCコンバータのラッチアップでした。GPSロガーを、誰でも製造できるように再設計(リファクタリング)することが、このプロジェクトの目的です。</P>

<H2>要件</H2>

<P> GPSロガーは、モデルロケットの飛行径路を計測するのに使用します。モデルロケットは、火薬を燃焼して得られるガスの噴射により、高度100m程度まで上昇します。その後、モデルロケットはパラシュートを開いて地上または水上に降下します。GPSロガーを使うと、高度も正確に測定することができます。</P>

<P> モデルロケットに搭載する以上、GPSロガーはできるだけ小さく、軽いことが望ましいのですが、前回は防水を兼ねたフィルムケースを使用していましたので、このプロジェクトでも同じものを使用することにしました。大昔の雑誌の記事(初歩のラジオ?)で、コニカ(当時はサクラカラー)よりもフジのフィルムケースの方が防水性が高いと読んだ記憶があり、富士写真フィルムの低感度用フィルムケースを使用しています。</P>

<P> 電源は内蔵する必要がありますので、電池を使用します。</P>

<P> それ以外の要件として、作りやすいことと、部品が入手しやすいことを重視しました。なお、GPSモジュールの部品については、前回と同じものを使用しています。</P>

<H2>設計コンセプト</H2>

<P> 要件を満たすために、どのような方針で設計をおこなうかですが、マルチメディアカード、またはその上位規格のSDカードを使用するという方針を仮定しました。これは以前「マルチメディアカードのSPIモードはクロック同期シリアルでアクセスできるので制御が簡単」と知人から聞いていたためです。個人的に経験を積んでおきたかったというのもあって、資料を調査し、採用しました。</P>

<P> サイズ的にも合格のはずだったのですが、適当なコネクタを手配し、カードを差してフィルムケースに入れてみたところ、厳しいことがわかりました。コネクタの作りによって大きさが違うのだと思いますが、部品が手配しにくくなるのは要件に反します。そこで、携帯電話やMP3プレーヤー向けに出回っているmini-SDカードを使用し、SDカードへの変換アダプタそのものをソケットにするように考えました。mini-SDカードは、アダプタ付きの製品が各社から提供されているため、入手は容易です。</P>

<P> なお、本システムではmini-SDカードをマルチメディアカードの上位互換品として使用しているのですが、以降の説明ではこれらを単に「SDカード」と呼ぶことにします。</P>

<P> フラッシュメモリLSIを基板に実装した場合とは異なり、SDカードは着脱可能ですから、GPSロガーは記録機能だけにし、別の機器にSDカードを差して読み出すことも可能になります。これにより、GPSロガーの単純化・軽量化が見込めます。</P>

<P> SDカードはPCでも読めるのですが、FATなどの標準的なフォーマットでない場合には、PC用の専用ソフトウェアを開発する必要があります。これは、PCの環境の変化(OSのバージョンアップなど)によって動かなくなる危険があり、保守性の低下につながります。一方、もしFATで書き出せれば、どんなPCでも読み出せることになり、保守性とシステムの単純化が期待できます。そこで、何らかの形でFATを書き出すことが目標になります。また、分析システムがPCに依存してしまったのでは意味がないので、分析システムを動かすプラットフォームについての検討も必要です。</P>

<H2>設計の詳細</H2>

<H3>-- 電源</H3>

<P> 今回の設計では昇圧はおこなわず、3.3Vのレギュレータの使用もしくは3.6Vの直接入力としています。GPSモジュールは3.3V程度を必要とし、100mA近く消費するので、当初は3V200mAhのコイン電池(CR2032)を2つ直列にして、レギュレータで3.3Vにする方針でいました。基板を起こした後に、コイン電池の放電能力について指摘をいただき、大電流放電が可能なNiMH電池に変更しました。最終的に、SANYOの3HB70(3.6V 公称容量70mAh)または、VARTAの互換品を使うことにしました。いずれも、通信販売などで幅広く入手できます。大電流放電なので、30分〜1時間で電池がなくなる計算になります。</P>

<P> 充電は、12VのACアダプタから電流制限抵抗を通して8時間充電するという単純なものです。</P>

<H3>-- 記録メディア</H3>

<P> mini-SDカードは32〜512MBのものが、各社から販売されています。PCショップなどで購入できます。</P>

<H3>-- マイコン</H3>

<P> 個人的に実績のあるPICの中で3.3Vが使えるものとなると、PIC12C509Aが思いつきます。これは8ピンのマイコンで、4MHzのRCクロックを内蔵しているため、部品点数が少なくできるという利点があります。比較的古く、機能も少ないのですが、フラットパッケージもあり、多数の店舗で入手できます。8ピンのうち電源は2ピンで、GPSモジュールとの送受信に2ピン、SDカードのアクセスに4ピンを割り当てることになります。</P>

<H3>-- ソフトウェアの機能</H3>

<P> PIC12C509AにはRAMが41バイトしかないため、普通のやり方ではFATを扱うことができません。つまり、1セクタ512バイトをメモリ上に読み込み、一部を変更してから書き戻すという処理をおこなうことができません。そこで、あらかじめPCを使ってメモリカード上にファイルを用意しておき、このファイルのデータ部分を1セクタ単位で更新していく方法を取ることにしました。</P>

<P> GPSモジュールからの受信はシリアル(9600N81)ですが、これの受信バッファも取れません。こちらについては、GPSモジュールの送信が間欠的であり、1秒に一度、何十バイトかがまとめて来るのを利用して対応します。具体的には、受信したデータはそのままセクタデータとしてSDカードに書き出します。送信が途切れたところで、ダミーデータを書き込んでセクタの残りを埋め、次のセクタに進み、次のデータの受信を待ちます。SDカードは、セクタの途中では書き込み待ちは発生しませんので、シリアルデータをそのまま書き込んでも取り落としはなく、データの途中でセクタが終わることもありません。</P>

<P> なおGPSモジュールから来るデータはバイナリですが、デバッグのしやすさ、ダミーデータの識別のしやすさを考え、データは16進ダンプ形式でテキストとして書き込みます。</P>

<H3>-- LED表示</H3>

<P> PIC12C509Aの入出力はすべて使用してしまっており空きがないのですが、動作の表示がほしいところです。そこで、SDカードのCS端子にLEDをつなぎ、アクセス中は点灯するようにしました。</P>

<P> 何らかの異常時には点滅回数でエラーコードを表示するようにしています。これは昔、自動車整備の雑誌で読んだ、自動車のエンジン制御コンピュータのエラーログ機能を参考にしたものです。</P>

<H3>-- 分析システムのプラットフォーム</H3>

<P> 分析システムはGUI環境上で使用したいわけですが、普及しているWindowsマシンは将来のバージョンアップなどに心配があり、一方でオープンなLinuxは誰でも簡単に利用できるとは言い切れない状況です。モデルロケットの打ち上げ現場にPCを持ちこむことにも不安があります。そこで、比較的後発のサーバサイドスクリプトであるPHPを使用し、インターネットブラウザを使ってアクセスする方法を採用しました。</P>

<P> PHPは無償で利用できるサーバサイド言語で、Apacheなどの主要なHTTPサーバから利用することができます。WindowsにもLinuxにも対応しています。標準でPHPが利用できるホスティングサービスも多数あり、公開ディレクトリに「.php」のファイルを置くだけで動作させることができます。このため、クライアントはインターネットブラウザさえ動作すればPCでもMacでもケータイでもよく、サーバ側は最悪でもPC+Linux+Apache+PHPとすることで確実に構築することができます。また、誰かが構築したサーバが公開されていれば、クライアント側は何もインストールしなくてもそこにアクセスするだけで動作しますので、プラットフォームへの依存が最小限に抑えられます。</P>

<P> PHPの言語仕様は、連想配列あり、クラスあり、多数の拡張モジュールありで、今回のようにファイルアップロード処理をおこなったり、画像の動的生成をおこなったりすることも簡単にできます。たとえば秋月電子通商のオンラインショップ(http://akizukidenshi.com/)もPHPで作られているようです。</P>

<H3>-- その他</H3>

<P> GPSモジュールは、GH-80という小型のものを用意していただきました。</P>

<P> 作りやすさを考え、DIP部品のみでも作れるようにしました。コストは圧縮したいので、基板は共用になっています。</P>

<H2>試作品</H2>

<P> 最初に、SDカードへのアクセスを検証するための試作基板を作りました。シリアルはPCに接続し、入力したアドレスのセクタダンプなどをおこなうものです。その後、MBR(マスターブートレコード)などの管理領域の読み込みをテストし、最終的にはメモリカードの先頭ファイルをシリアルに出力するテストをおこないました。ここまでくれば、読み込みを書き込みに変更することで書き込みが可能になります。</P>

<P> GPSモジュールとの通信は、まずレベルコンバータ(トランジスタ2個)を使ってPCに接続してテストし、その後PICに持っていきました。</P>

<P> GPSモジュールの感度が低い問題が発覚し、受信データをLCDに表示するためのボードも用意しました。LCDモジュールは5Vなので、PIC16F84Aを使用しました。</P>

<P> プリント基板のアートワークですが、試作品と同じピン配置にしたため、電源が引き回されて完成度が低くなっています。当初はコイン電池2個を直列にして6Vを得る考えだったため、3端子レギュレータのパターンが残っています。</P>

<H2>PICによるFATアクセス</H2>

<P> PIC12C509Aはメモリが少ないため、セクタのデータを1バイトずつ読み込みながらのデータ処理と、1セクタまとめてのデータ書き込みしかできません。SDカードのブロック長設定機能を使い、1セクタ=1バイトにする方法も考えましたが、あらゆるSDカードでサポートされているか自信がなかったこと、シリアルの受信速度に追いつけない可能性があることを理由に見送りました。ちなみに、PIC12C509Aにはシリアル通信のためのハードウェア(SIO)もありません。</P>

<P> 管理領域の読み込みについては、セクタリードコマンドを発行した後、必要なデータが来るまで読み飛ばし、その後データを読んで判断し、残りを読み飛ばすという動作になります。FATから次のエントリを読み出す処理は、たとえば最初の10バイトは読み飛ばし、次の2バイトを読み込み、その後の500バイトは読み飛ばす、という処理になります。1クラスタごとにこの処理をおこなうわけですが、SDカードのアクセスは高速なので、シリアルデータが途切れたときに処理することで十分に間に合います。今回の実装では、このタイミングで250ミリ秒間LEDを消灯し、動作の表示をおこなっています。</P>

<P> 動作は、最初にMBR(マスターブートレコード)を読み込んでパーティションテーブルから最初のパーティションの開始セクタを取り出し、そこからPBR(パーティションブートレコードまたはBIOSパラメータブロック)を読み込みます。PBRを見て、FATのセクタ数と、1クラスタあたりのセクタ数を得ます。ここからRDE(ルートディレクトリエントリ)のアドレスが求まり、最初の1セクタ(16エントリ)の中から、書き込み対象のファイル名を見つけて、その先頭クラスタに書き込みを開始します。1クラスタが2セクタ以上ある場合は、セクタ数だけくり返します。1クラスタの書き込みが完了したら、FAT(ファイルアロケーションテーブル)を読み込み、次のクラスタ番号を得て、書き込みを続けます。</P>

<P> 当然、この方法では管理領域の更新はできず、ファイルサイズや更新日時は元のままになります。またFAT12については、1エントリが2セクタにまたがる場合があるため、対応を見送りました。</P>

<H2>その他</H2>

<H3>-- 内蔵プルアップ抵抗</H3>

<P> PIC12C509Aには、レジスタの設定で、いくつかのピンのプルアップ抵抗を有効にすることができます。そこで、GPSモジュールからのシリアル受信端子と、SDカードからのデータ受信端子は、プルアップ抵抗の効くピンに割り当てることで、外部のプルアップ抵抗を節約することができます。</P>

<H3>-- ワンタイムROMでの値の調整</H3>

<P> PIC12C509AのダイはEPROMになっており、開発は窓付きのパッケージ(JWタイプ)を使用します。組み込み時には窓がなく消去できないワンタイム品を使うのですが、動作結果を見て値を調整したい場合もあります。</P>

<P> このときは、EPROMの先頭部分に「movlw 7fh」を、続いて「andlw 0ffh」をいくつか(筆者の場合は8〜16個)置き、最後に「movwf param0」のようにしてメモリに保存します。「andlw 0ffh」のバイナリコードは0xeffで、動作は「W =&amp; 0xff」なのでWレジスタの値は変化しません。したがってこのコード列は、最初に「movlw 7fh」でWレジスタが0x7fになったあと、「andlw 0ffh」の並びでは何も起きず、最後に「movwf param0」でメモリに保存されることになります。この状態では、0x7fがメモリに保存されます。</P>

<P> 値を変えたいときは、最初の「andlw 0ffh」を「movlw 34h」のように変更します。「movlw 34h」のバイナリコードは0xc34で、下位8bitがオペランドになります。EPROMは、初期化時は全ビットが1で、書き込むと0になりますので、0xeffに0xc34を上書きすることが可能なのです。</P>

<P> 必要であれば、この並びを何組か持っておくと、たとえばクロックやタイマーの調整、ステッピングモータの速度の調整、ストロークの調整、IDの書き換えなど、様々な目的に利用することができます。</P>

<H3>-- 逆差し対策</H3>

<P> 私は基板側のコネクタはピンヘッダを使うことが多いのですが、逆差しを防止できないという欠点があります。そこで、逆差ししても逆電圧がかかったりしないように、配列を工夫しています。</P>

<H3>-- ケータイ対応</H3>

<P> 将来的に携帯電話からのインターネットアクセスを考慮して、衛星捕捉まで記録を開始しないモードを用意しました。ファイル名をgpsd.logにするとこのモードになり、ファイルサイズが小さくて済むため、携帯電話のような低速通信の機器に向いています。mini-SDカードからのファイルアップロードができる携帯電話があれば、そのままサーバに送信して結果を分析することができます。</P>

<P> また、imexportというディレクトリがあると、その中のgps.logを検索するようになっています。これは、このディレクトリに添付ファイルを格納する携帯電話に対応するためのものです。</P>

<H2>トラブルの記録</H2>

<H3>-- ボタン電池の放電電流</H3>

<P> 当初はコイン電池(金属リチウム一次電池)を使う予定だったのですが、ある方に指摘されてデータシートを調べたところ、連続した大電流放電は保証外のようでした。参考にしたデータシートを以下に示します。</P>

<UL>
	<LI>
<A href="http://www.gpbatteries.com.hk/pic/GPCR2032_DS.pdf">
http://www.gpbatteries.com.hk/pic/GPCR2032_DS.pdf</A>
</UL>

<H3>-- mini-SDアダプタの接続方法</H3>

<P> mini-SDアダプタはプラスチック製のため、熱に弱いという心配がありました。そこで、初めて導電性接着剤を使ってみたのですが、それなりにコツが必要なようです。修正ペン型のものは粘性が低く、mini-SDアダプタの端子ガードの下に浸透して端子間で短絡してしまいました。また、固まったあとは脆いようです。2液混合エポキシ型も試してみたのですが、結果的に原因不明で端子間の短絡が発生しました。</P>

<P> 導電性粘着剤を使用した銅箔テープ(シールド用)も試したのですが、安定した接続が得られませんでした。最終的に、製造マニュアルにあるように、半田付けで対応しました。</P>

<H3>-- アドレスの制限</H3>

<P> PIC12C509Aにはメモリが2バンクあります。0〜0x1fと、0x20〜0x3fで、それぞれ一部のみ実装されています。バンクはFSR(ファイルセレクトレジスタ)でアドレスを指定すると切り替わるのですが、このとき直接アドレスでアクセスするメモリにも影響があります。FSRを0x30にすると、0x20〜0x3fのバンクが有効になるため、0x14のメモリへの読み書きは実際には0x34におこなわれます。このため、どちらのバンクからもアクセスする変数は、0〜0xfの範囲に置く必要があります。なお、実際に使用可能なメモリは、7〜0x1fと0x30〜0x3fの41バイトです。</P>

<P> また、PIC12C509Aには1024ワードのプログラムメモリがありますが、call先に指定できるアドレスは0〜0xffという制限があります。また、goto先に指定できるアドレスは0〜0x1ffと0x200〜0x3ffのどちらか片方のみで、ステータスレジスタで切り替える仕組みになっています。サブルーチン類は先頭に固めておき、サブルーチン内のgotoが正常に動作するよう、後半512ワードから呼び出す場合にはステータスレジスタを設定しておく必要があります。</P>

<P> ちなみに、PIC12C509Aではcallのネストは2回までしかできません。メインルーチンからrssendを呼び、その中からrswaitを呼ぶことはできますが、それ以上呼ぶと、スタックが上書きされてしまい、メインルーチンに戻れなくなります。</P>

<H3>-- PICの内蔵クロック</H3>

<P> PIC12C509の内蔵4MHzクロックは、レジスタに微調整パラメータを書き込んで使用します。工場出荷時は5Vで校正された値が、プログラムメモリの最後に書き込まれ、電源投入時はここから実行が開始されます。</P>

<P> シリアルの受信化け(ストップビットがビット7に出てしまう)が出たとき、このシステムの動作電圧である3.6Vではクロックが遅くなっているのではないかと想像したのですが、実際に計測してみたところ影響のあるような遅れは見られませんでした。これは結局、定数のミスと判明しました。</P>

<H3>-- GPSモジュールの受信感度</H3>

<P> 調査中ですが、このシステムでは、衛星捕捉能力について、GPSモジュールの実力が発揮できていないようです。電源の問題、シールドの問題などが考えられます。今までの実験結果は、以下の通りです。</P>

<TABLE border>
<TR><TH>battery type
	<TH>PIC type
		<TH>case type
			<TH>log
				<TH>status
<TR><TD>NiMH direct
	<TD>flat
		<TD>in film-case
			<TD><A href="glog/gl050718.log">gl050718.log</A>
				<TD>broken
<TR><TD>UM3x3 regulated
	<TD>DIP-JW
		<TD>open
			<TD><A href="glog/gln50807.log">gln50807.log</A>
				<TD>good
<TR><TD>UM3x3 regulated
	<TD>DIP-JW
		<TD>with Cu plate(50x50)
			<TD><A href="glog/gls50807.log">gls50807.log</A>
				<TD>good
<TR><TD>NiMH direct
	<TD>DIP-JW
		<TD>in film-case
			<TD><A href="glog/gl050813.log">gl050813.log</A>
				<TD>bad
<TR><TD>NiMH + 470uF
	<TD>DIP-JW
		<TD>in film-case
			<TD><A href="glog/gle50814.log">gle50814.log</A>
				<TD>bad
<TR><TD>NiMH + 470uF
	<TD>DIP-JW
		<TD>with Cu plate(50x50)
			<TD><A href="glog/gl050815.log">gl050815.log</A>
				<TD>good
<TR><TD>NiMH
	<TD>DIP-JW
		<TD>open
			<TD><A href="glog/gl050817.log">gl050817.log</A>
				<TD>good(1.5-2min)
</TABLE>

<H2>振り返り</H2>

<P> 何もしなくても動くくらい、単純な設計を目指したのですが、GPSモジュールの感度の問題は原稿執筆時点では未解決です。それ以外については、ハードウェアの問題は致命的なものは避けられ、期待通りの結果が得られたと考えています。</P>

<H2>参考文献</H2>


<UL>
	<LI>TECH I Vol.14 PCカード/メモリカードの徹底研究(CQ出版社)
	<LI>FAT FSフォーマットの実装についての覚え書き(
<A href="http://www.geocities.co.jp/SiliconValley-PaloAlto/2038/fat.html">
http://www.geocities.co.jp/SiliconValley-PaloAlto/2038/fat.html</A>
)</P>
	<P>
	<LI>その他、各種データシート・マニュアル</P>
</UL>

<HR>
</BODY></HTML>
