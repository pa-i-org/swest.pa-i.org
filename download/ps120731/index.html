<HTML><HEAD><TITLE>テストカバレッジ100%への旅</TITLE></HEAD><BODY>
<H1>テストカバレッジ100%への旅</H1>
<H2>ゴール指向モデリングの現状とロードマップ</H2>

<P>テストには大きなジレンマがあります。修正版が出る都度、インストールから始めて全部をテストする、というのが1つ目の考え方です。この考え方の根拠は、ある箇所の修正が、なぜか思ってもみなかったところに影響することがある、というものです。イベント管理を修正したら、なぜかインストーラがディスクをフォーマットするようになってしまった、ライブラリに修正が入ったらなぜか関係ないところでプロセッサ例外が発生するようになった、上司が出張に行ったらなぜか仕事がはかどるようになった、などです。</P>

<P>もう1つの考え方は、修正版が出たら、修正された箇所だけをテストする、というものです。この根拠は、もし問題か見つかったら、次の修正版が出てテストし直さないといけないのだから、早いフィードバックが重要である、というものでしょう。</P>

<P>もしあなたがテストの管理を任されたら、この2つのうちのどちらに従うかを決断しないといけません。前者を選べば、修正版は1〜2週間ごとにまとまってリリースされるでしょう。この間隔は、全体の通り一遍のテストに、修正部分の十分なテストに必要な時間を加えたものになるべきですが、現実にそうなるのは、マスターアップのあとと、開発サイドで大トラブルが発生してリリースが止まった場合に限られると思います(マスターアップのあとに深刻な問題が見つかるのは、このためでしょう)。後者を選べば、修正の都度リリースがおこなわれ、修正のあった箇所のまわりを調べることになるでしょう。</P>

<P>もちろん、デイリービルドや自動テストなどのテクニックはあります。しかし、製品をリリースするときには、全体を手でテストしないといけません。もし、そこで問題が見つかったら、大抵は修正しなければならないでしょう。何度も繰り返されれば、夏休みの宿題のような結果になります。これは特に、ハードウェア製品のような、後からのアップデートができないものについて言えることです。</P>

<P>例えば、電源がオフになるときにデータが壊れる、という問題が見つかったとします。これはあくまでも架空のケースですが、このときは周辺機器の組み合わせによって発生しました。このような問題は、すべての境界条件を見つけることができないため、自動テストが難しいものです。OSが起動する過程のすべてのタイマ割り込み、マウス割り込み、ハードディスクのDMA完了割り込みの何十万回もの発生順序を、全部テストすることはできません。</P>

<HR>

<P>実は私は、PC用のOS(BTRON)を開発する会社に8年間いました。もちろん、ただ居ただけではなく、OSや周辺モジュール、システムアプリケーションなどの設計・開発・保守などをおこないました。それだけでなく、サポートチームとの情報交換、各種アプリケーションの自主開発、記事や辞表の執筆もおこないました。</P>

<BLOCKQUOTE>※土屋健二氏の本を読んだところなので、ちょっと影響されています。</BLOCKQUOTE>

<P>私が扱っていた典型的なモジュールは、バイナリサイズにして100〜300KBあります。C言語の1行が平均10バイトになるとすると、約1万行〜3万行ということになります。OS製品には、このようなモジュールが何十もあります。さらに、フォントや辞書、マニュアル、こっそり入れた「開発者向け」機能や、取り損ねたバグと仕様が、製品CDに入ります。</P>

<P>CDを作るということは、もし問題があった場合には直接の損害が発生するということです。従ってここでも同様のジレンマを経験しました。</P>

<HR>

<P>ところで世の中には、ある箇所を修正したときに、他の箇所に影響が及ばないシステムあります。その代表例がmakeです。</P>

<P>makeはビルドツールで、「ファイルa.outを作るには、x.oとy.oが必要である。その方法は…」「ファイルx.oを作るには、x.cとa.hが…」といった形で箇条書きにします。するとmakeは、a.outを作るには、まずx.oを作り、そのあとa.outを作る、といった動作をおこないます。この箇条書きが何千行あったとしても、ファイルを追加したり削除したりするときは、関係する一部だけを修正すればokです。具体的には、追加したファイルを必要としているところに項目を追加し、あとはファイルの作り方を書くだけです。</P>

<P>全体を確認する必要はなく、その証拠に、しばらくすると箇条書きのどこに何が書かれているか、誰も覚えていません。車のキーレスエントリーシステムを使いはじめると、どこに停めたかを誰も覚えなくなるのと同じです。</P>

<HR>

<P>この考え方を、組み込みシステムに応用することは可能でしょうか。例として、レーザーカラオケを考えてみます。</P>

<P>LinuxとX window systemがリモコンに載っている最近の通信カラオケからは想像できないと思いますが、レーザーカラオケはテレビのチャンネルがロータリースイッチだった時代のもので(嘘です)、144枚のレーザーディスクを収容したチェンジャーがあり、入れ替えの時間ロスを避けるためにプレーヤーが2台あります。プレーヤーは両面再生に対応しており、典型的にはA面にポップスが、B面に演歌が入っていて、雨の日に林のわきの橋のたもとで、和服の女の人が赤い和傘をさして遠くを見たりする映像が含まれています。</P>

<P>あるディスクをプレーヤーに入れるには、キャリアとプレーヤーが空の状態で、そのディスクの位置にキャリアを動かし、ディスクを取り出して、プレーヤーのところにキャリアを動かし、ディスクを挿入すればokです。ここで重要なのは「プレーヤーとキャリアが空の状態で」という部分です。プレーヤーを空にするには、キャリアが空の状態で、キャリアを(中略)します。makeの考え方を使えば、こういう処理が自然に書けることは、想像していただけると思います。</P>

<BLOCKQUOTE>※ときに、10万曲も入っている通信カラオケのテストは、どうやるのでしょうか。1曲の平均が4分だとすると、全部再生するだけで半年以上かかります。しかも、採点とかハモリとかキーチェンジとか外国語とか、いろいろな機能の組み合わせもあります。</BLOCKQUOTE>

<P>さて、makeの考え方だけでは十分ではありません。というのは、組み込みシステムでは途中でゴールが変わることがあるからです。例えば、ディスクを入れ替えている途中でキャンセルされたり、静電気でディスクが詰ったり、次のディスクを読み込んでいつでも再生できるぞさあかかってこいというところで割り込みボタンが押され、せっかくの準備が無駄になってしまったり、最後に締めの曲を用意して意気揚々と待っていたら終了の時間が来て歌えなかったりなどです。つまり、ゴールの変化に対応できる仕組みが必要なわけです。</P>

<HR>

<P>今回の「ゴール指向モデリング」は、makeの考え方に加えて、ゴールの状態遷移を扱うものです。これはゴールの変化だけを追えばよいので、世界最大のロジックパズルのような、誰も確認する気の起きない巨大な状態遷移表にはなりません。例えば、エレベータの制御上のゴールは、押しボタンのランプをすべて消すことです。押しボタンのランプは、その階に止まってドアを開ければ消えます。あとはこの延長で必要な処理をおこなえば、エレベータは勝手にうまく運行されるわけです。</P>

<P>この考えを高田先生に話したら、じゃあエレベータが何台もあるときはどうするんだと聞かれましたが、それは動的ゴール指向モデリングという上位の枠組みで考えることにしましょう。ここでは、ゴールを目指すように自動運転させれば、詳細は書かなくても動くということが伝われば十分です。ちなみに動的ゴール指向モデリングは、ゴールへの道がコンパイル時に確定しないものを指す名前であって、まだ何も考えていないことを誤魔化すものではありません。</P>

<P>本稿の冒頭で、テストのジレンマの話をしました。ゴール指向モデリングは、テストにどう関係あるでしょうか。それは、1つはmakeのように、一部の修正が他に影響を及ぼしにくくなること、もう1つは状態遷移の数を減らすことで、テストの境界条件が減ることです。あるゴールが目標に設定されているときに、どの状態からだったらどういう経過をたどってゴールにたどりつくかが明確になります。こうして、設計レベルで問題を見つけ出せるチャンスが増えることで、テストを減らすことができると考えています。</P>

<P>ゴール指向モデリングは、SWEST当日までにはコード生成のデモができている状態のはずです(4件のデスマーチと部屋が片付けば)。状態遷移によってテストケースが爆発して困っている方がいらっしゃいましたら、最新情報をお知らせしますのでお問い合わせください。</P>

<P><IMG alt="ゴール指向モデリングで使用する図記号" src="sgom.png" width="620" height="877"></P>

<P>参考文献:</P>
<UL>
<LI>DOMAIN-SPECIFIC MODELING / Steven Kelly, Juha-Pekka Tolvanen
<LI>IT'S NOT LUCK (邦題:ザ・ゴール2) / Eliyahu M. Goldratt
<LI>Web Operations: Keeping the Data on Time (邦題:ウェブオペレーション) / John Allspaw, Jeese Robbins
<LI>Time Management for System Administrators (邦題:エンジニアのための時間管理術) / Thomas A. Limoncelli
<LI>紅茶を注文する方法 / 土屋健二
</UL>

<P>お問い合わせ先:<BR>
きもと特急電子設計 木元峰之<BR>
post@business.pa-i.org<BR>
http://business.pa-i.org/</P>


<P>本文中の体験談はすべてフィクションであり、実在の勤務先とは一切関係ありません。</P>

<HR>
</BODY></HTML>

